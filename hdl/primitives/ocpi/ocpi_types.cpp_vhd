// This file generates the VHDL definitions for the OpenCPI property and protocol data types.
// The types are based on the ieee.std_logic and ieee.numeric_std packages.
// It should be processed into the ocpi library and accessed via ocpi.type.xxx.

library ocpi;
use ocpi.wci.all;
library ieee;
use IEEE.std_logic_1164.all;
use ieee.numeric_std.all;
library std;
use std.all;
package types is
-- These types are the mapping of the OpenCPI scalar types to VHDL.
-- We use std_logic vector types and avoid native types.
-- These ranges match the IDL specification
--
-- boolean type, convertible to/from vhdl native boolean
--
subtype Bool_t is boolean; --std_logic;
--function To_boolean (b : Bool_t) return boolean;
function To_bool(b : std_logic) return Bool_t;
function To_bool(b : std_logic_vector) return Bool_t;
function from_bool(b : bool_t) return std_logic_vector;
--
-- char type, convertible to/from vhdl native character, and integer (due to numeric_std)
--
subtype char_t is signed (7 downto 0);
constant char_min : char_t := to_signed(-128,8);
constant char_max : char_t := to_signed(127,8);
function To_character (c : Char_t) return character;
function To_char (c: Character) return char_t;
function To_char (c: integer) return char_t;
function from_char (c: char_t) return std_logic_vector;
--
-- double type - no VHDL conversions defined
--
subtype double_t is std_logic_vector (63 downto 0);
constant double_min : double_t := x"0010_0000_0000_0000"; -- 2.2250738585072014e-308
constant double_max : double_t := x"7fef_ffff_ffff_ffff"; -- 1.7976931348623157e+308
--
-- float type - no VHDL conversions defined
--
subtype float_t is std_logic_vector (31 downto 0);
constant float_min : float_t := x"0080_0000"; -- 1.17549435e-38
constant float_max : float_t := x"7f7f_ffff"; -- 3.40282347e+38
--
-- short type - convertible to/from vhdl native integer
--
subtype short_t is signed (15 downto 0);
constant short_min : short_t := x"8000";
constant short_max : short_t := x"7fff";
function To_short (c: integer) return short_t;
--
-- long type - convertible to/from vhdl native integer
--
subtype long_t is signed (31 downto 0);
constant long_min : long_t := x"8000_0000";
constant long_max : long_t := x"7fff_ffff";
function To_long (c: integer) return long_t;
--
-- uchar type - convertible to/from vhdl native natural
--
subtype uchar_t is unsigned (7 downto 0);
constant uchar_max : uchar_t := to_unsigned(255, 8);
function To_uchar (c: natural) return uchar_t;
--
-- ulong type - convertible to/from vhdl native natural
--
subtype ulong_t is unsigned (31 downto 0);
constant ulong_max : ulong_t := x"ffff_ffff";
function To_ulong (c: natural) return ulong_t;
--
-- ushort type - convertible to/from vhdl native natural
--
subtype ushort_t is unsigned (15 downto 0);
constant ushort_max : ushort_t := x"ffff";
function To_ushort (c: natural) return ushort_t;
--
-- longlong type - convertible to/from vhdl native integer (perhaps)
--
subtype longlong_t is signed (63 downto 0);
constant longlong_min : longlong_t := x"8000_0000_0000_0000";
constant longlong_max : longlong_t := x"7fff_ffff_ffff_ffff";
--
-- ulong type - convertible to/from vhdl native natural
--
subtype ulonglong_t is unsigned (63 downto 0);
constant ulonglong_max : ulonglong_t := x"ffff_ffff_ffff_ffff";
--
-- string type - array of char
--
type string_t is array (natural range <>) of char_t;
subtype wordstring_t is string_t(0 to 3);
function to_string(inword : word_t) return wordstring_t;
function from_string(s : string_t; offset : unsigned) return word_t; --std_logic_vector;
--
--
-- Property storage entities to attach to a wci.decoder
--
-- Declarations for various property implementationss

#define WPROP(pretty,which,def,rng,io) \
$--\
$-- registered pretty property value, with write pulse \
$--\
$component pretty##_property \
$@@generic(worker : worker_t; property : property_t; default : pretty##_t := def); \
$@@port (clk          : in std_logic; \
$@@@@@@@@reset        : in boolean; \
$@@@@@@@@write_enable : in boolean; \
$@@@@@@@@data         : in std_logic_vector(rng); \
$@@@@@@@@value        : out pretty##_t; \
$@@@@@@@@written      : out boolean); \
$end component;

#define RPROP(pretty,which,def,rng,io) \
$--\
$-- readback scalar <=32 property \
$--\
$component read_##pretty##_property \
$@@generic (worker : worker_t; property : property_t); \
$@@port (value       : in pretty##_t; \
$@@@@@@@@data_out    : out std_logic_vector(31 downto 0)); \
$end component;

#define WPROP_STRING(pretty,which,def,rng,io) \
$--\
$-- registered pretty property value, with write pulse \
$--\
$component pretty##_property \
$@@generic(worker : worker_t; property : property_t; default : pretty##_t := def);\
$@@port (clk          : in std_logic;\
$@@@@@@@@reset        : in boolean;\
$@@@@@@@@write_enable : in boolean;\
$@@@@@@@@data         : in std_logic_vector(rng);\
$@@@@@@@@value        : out pretty##_t(0 to property.string_length);\
$@@@@@@@@written      : out boolean;\
$@@@@@@@@offset       : in unsigned(worker.decode_width-1 downto 0));\
$end component;

#define RPROP_STRING(pretty,which,def,rng,io) \
$--\
$-- readback scalar <=32 property \
$--\
$component read_##pretty##_property \
$@@generic (worker : worker_t; property : ocpi.wci.property_t); \
$@@port (value       : in pretty##_t; \
$@@@@@@@@data_out    : out std_logic_vector(31 downto 0); \
$@@@@@@@@offset      : unsigned(worker.decode_width-1 downto 0)); \
$end component;

#define WPROP_64(pretty,which,def,rng,io) \
$--\
$-- registered pretty property value, with write pulse \
$--\
$component pretty##_property \
$@@generic(worker : worker_t; property : property_t; default : pretty##_t := def); \
$@@port (clk          : in std_logic; \
$@@@@@@@@reset        : in boolean; \
$@@@@@@@@write_enable : in boolean; \
$@@@@@@@@data         : in std_logic_vector(31 downto 0); \
$@@@@@@@@value        : out pretty##_t; \
$@@@@@@@@written      : out boolean; \
$@@@@@@@@hi32         : in boolean); \
$end component;

#define RPROP_64(pretty,which,def,rng,io) \
$--\
$-- readback scalar >32 property \
$--\
$component read_##pretty##_property \
$@@generic (worker : worker_t; property : property_t); \
$@@port (value       : in pretty##_t; \
$@@@@@@@@data_out    : out std_logic_vector(31 downto 0); \
$@@@@@@@@hi32        : boolean);\
$end component;

#define WPROP_ARRAY(pretty,which,def,io) \
$type pretty##_array_t is array (natural range <>) of pretty##_t;\
$--\
$-- registered pretty property array value, with write pulse\
$--\
$component pretty##_array_property \
$@@generic(worker : worker_t; property : property_t; default : pretty##_t := def); \
$@@port (clk          : in std_logic; \
$@@@@@@@@reset        : in boolean; \
$@@@@@@@@write_enable : in boolean; \
$@@@@@@@@data         : in std_logic_vector(31 downto 0); \
$@@@@@@@@value        : out pretty##_array_t(0 to property.nitems-1); \
$@@@@@@@@written      : out boolean; \
$@@@@@@@@index        : in unsigned(worker.decode_width-1 downto 0); \
$@@@@@@@@any_written  : out boolean; \
$@@@@@@@@nbytes_1     : in ocpi.wci.byte_offset_t);\
$end component;

#define RPROP_ARRAY(pretty,which,def,io) \
$--\
$-- readback scalar <=32 property array \
$--\
$component read_##pretty##_array_property \
$@@generic (worker : worker_t; property : property_t); \
$@@port (value       : in pretty##_array_t(0 to property.nitems-1); \
$@@@@@@@@data_out    : out std_logic_vector(31 downto 0); \
$@@@@@@@@index       : in unsigned(worker.decode_width-1 downto 0); \
$@@@@@@@@nbytes_1    : in ocpi.wci.byte_offset_t);\
$end component;

#define WPROP_64_ARRAY(pretty,which,def,io) \
$type pretty##_array_t is array (natural range <>) of pretty##_t;\
$--\
$-- registered pretty property array value, with write pulse\
$--\
$component pretty##_array_property \
$@@generic(worker : worker_t; property : property_t; default : pretty##_t := def);\
$@@port (clk          : in std_logic;\
$@@@@@@@@reset        : in boolean;\
$@@@@@@@@write_enable : in boolean;\
$@@@@@@@@data         : in std_logic_vector(31 downto 0);\
$@@@@@@@@value        : out pretty##_array_t(0 to property.nitems-1);\
$@@@@@@@@written      : out boolean;\
$@@@@@@@@index        : in unsigned(worker.decode_width-1 downto 0);\
$@@@@@@@@any_written  : out boolean;\
$@@@@@@@@hi32         : in boolean);\
$end component;

#define RPROP_64_ARRAY(pretty,which,def,io) \
$--\
$-- readback scalar >32 property array \
$--\
$component read_##pretty##_array_property \
$@@generic (worker : worker_t; property : property_t); \
$@@port (value       : in pretty##_array_t(0 to property.nitems-1); \
$@@@@@@@@data_out    : out std_logic_vector(31 downto 0); \
$@@@@@@@@index       : in unsigned(worker.decode_width-1 downto 0); \
$@@@@@@@@hi32        : in boolean);\
$end component;

#define WPROP_STRING_ARRAY(pretty,which,def,io) \
$type string_array_t is array (natural range <>,natural range <>) of char_t;\
$--\
$-- registered pretty property array value, with write pulse\
$--\
$component pretty##_array_property \
$@@generic(worker : worker_t; property : property_t; default : pretty##_array_t := (def,def)); \
$@@port (clk          : in std_logic; \
$@@@@@@@@reset        : in boolean; \
$@@@@@@@@write_enable : in boolean; \
$@@@@@@@@data         : in std_logic_vector(31 downto 0); \
$@@@@@@@@value        : out pretty##_array_t(0 to property.nitems-1,\
$@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ 0 to (property.string_length+4)/4*4-1);\
$@@@@@@@@written      : out boolean;\
$@@@@@@@@index        : in unsigned(worker.decode_width-1 downto 0);\
$@@@@@@@@any_written  : out boolean; \
$@@@@@@@@offset       : in unsigned(worker.decode_width-1 downto 0));\
$end component;

#define RPROP_STRING_ARRAY(pretty,which,def,io) \
$--\
$-- readback string property array \
$--\
$component read_##pretty##_array_property \
$@@generic (worker : worker_t; property : property_t);\
$@@port@@@ (value@@@ : in@ pretty##_array_t(0 to property.nitems-1,\
$@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@0 to (property.string_length+4)/4*4-1);\
$@@@@@@@@@@@data_out : out std_logic_vector(31 downto 0);\
$@@@@@@@@@@@offset@@ : in@ unsigned(worker.decode_width-1 downto 0));\
$end component;

#define TYPE(type,def,rng,suff,asuff) \
  WPROP##suff(type,X,def,rng,) \
  WPROP##asuff##_ARRAY(type,X,def,)\
  RPROP##suff(type,X,def,rng,) \
  RPROP##asuff##_ARRAY(type,X,def,)\

#define TYPEV(type) TYPE(type,(others => '0'),type##_t~range,,)
#define TYPEV64(type) TYPE(type,(others => '0'),type##_t~range,_64,_64)

TYPE(bool,false,0 downto 0,,)
TYPEV(char)
TYPEV64(double)
TYPEV(float)
TYPEV(short)
TYPEV(long)
TYPEV(uchar)
TYPEV(ulong)
TYPEV(ushort)
TYPEV64(longlong)
TYPEV64(ulonglong)
TYPE(string,("00000000","00000000"),31 downto 0,_STRING,_STRING)

function from_bool_array(ba : bool_array_t; index, nbytes_1, byte_offset : unsigned) return word_t;

end package types;
