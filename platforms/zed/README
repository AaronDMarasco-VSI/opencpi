This directory contains information and scripts for using OpenCPI on the
embedded linux on a Zed board with a Zynq chip on it.  It is focused on the
Linux released from Xilinx at http://www.wiki.xilinx.com/Zynq+Releases.  We
simply use the Xilinx linux release corresponding to the Xilinx ISE tools
release. (Vivado will come later...).  We prepare an SD card by copying the
files from the Xilinx release onto the card.  If the SD card is not formatted
correctly, you can use the instructions at
http://www.wiki.xilinx.com/Prepare+Boot+Medium, but if it already formatted
(like the SD card that comes with the Zed board), you simply copy these files
onto the SD card (when mounted on a different system).

There are literally 10s of "getting started on the zed board" documents for
various projects and purposes, but this one focuses simply on getting the zed up
and running as an OpenCPI embedded host, using the standard Linux kernel as
provided by Xilinx.  For those inclined, there's many more fancy things to do
with configuring and rebuilding the Linux kernel, but not needed at all here.

These instructions assume that the SD card is plugged in and mounted on a
Centos6 system.

From the "release archive" that you downlaoded from Xilinx, e.g. at

 http://www.wiki.xilinx.com/file/view/14.6-release.tar.xz/442481622/14.6-release.tar.xz

You first unpack it, then copy the appropriate files onto the SD card.  Assuming
the downloaded file (14.6-release.tar.xz) is in this directory (where this
README is), and the SD card is mounted at /mnt/sd, do:

% mkdir 14.6-release
% cd 14.6-release
% tar xvJf ../14.6-release.tar.xz
% cp uImage uramdisk.image.gz zed/boot.bin zed/devicetree.dtb /mnt/sd
% cd ..
% cp setup.sh /mnt/sd

This creates a bootable card for the Zed board with the released Xilinx kernel
and boot loader, and a generic "setup" script for getting OpenCPI going.
You should add one more file to the SD card that is customized for your
development situation.  It calls the "setup.sh" script with the appropriate
arguments for your environment and does whatever other setup tasks you want.
An example is in mysetup.sh.  Assuming you use that name:

% cp mysetup.sh /mnt/sd

You now need to unmount the SD card it, removing it, and plug it into the
powered-off Zed board.


When Linux boots on the Zed board from the SD card created as above, it creates
a memory-based root file system, initialized from decompressing the
uramdisk.image.gz file on the SD card.  It does NOT mount the SD card itself as
a file system, although that can be done after booting.  This means that
anything you write to the root file system is NOT persistent.  To create any
persistent file you must first mount the SD card file system and write files to
that file system, usually mounted as /mnt/sd or /mnt/card.

OpenCPI typically uses a built-in NFS client to access the development tree from
these types of systems (in a development environment anyway), and the default
Linux configuration built by Xilinx happily includes NFS client support.

Before using the zed board for OpenCPI, you need to build OpenCPI for the Zynq
architecture on Linux.  Assuming you have OpenCPI and Xilinx ISE tools installed
along with the Xilinx EDK package, you just go to the top level of the OpenCPI
tree, set up your environment for building for Zynq Linux, and then build
OpenCPI, the software components, and the test FPGA bit streams.

To set up the build environment, first install and build OpenCPI for the native
development system (this is described elsewhere).

Next, look at the script "jkzed.sh", modify it for your Xilinx ISE tools
installation, and then source it IN A NEW SHELL/WINDOW on the development system
(not on the Zed!).

% source ./jkzed.sh

Then if all is well:

% make; make rcc; make hdl HdlPlatform=zed

This will cross-build the OpenCPI libraries, software components, and test FPGA
bitstreams for Zynq on Zed.

********* Now you can bring up the zed board and run OpenCPI ***********

================================================================================

To first start using the Zed board you need to do these things:

================================================================================

********* Basic board physical configuration and power up test ***********

Step 0: Always be careful of static electricity when touching the board.
Touch some metal shell first each time. Start with the power cable disconnected.

Step 1: Set the jumpers on the board correctly, according to the Digilent README
file on the original SD card:

    MIO 6: set to GND
    MIO 5: set to 3V3
    MIO 4: set to 3V3
    MIO 3: set to GND
    MIO 2: set to GND

    VADJ Select: Set to 1V8

    JP6: shorted (JEK: note I didn't have enough jumpers and this wasn't needed...)
    JP2: shorted

    All other jumpers should be left unshorted.

    Make sure the power switch is OFF

Step 2: Insert the SD card into the socket on the bottom of the board.

Step 3: Connect the supplied micro-USB-to-normal-USB-cable to a system
with a terminal emulator to provide access to the Zed system console,
set to 115200 board, 8 data bits, 1 stop bit, no parity.  There
are two different connectors on the board: be sure to use the one
labelled: UART, and NOT the one labelled USB OTG.

Step 4: Attach the power cable

Step 5: Turn the power switch on.  The green POWER LED should come on.
The system has actually booted itself, but without a console attached
you can't really see anything.

================================================================================

**** Next Steps are to get access to the serial system console of the Zed ******

Step 6: Establish Serial Console Communications on the Linux Development Host

Since the OpenCPI development environment is running on a Linux system (usually
Centos6), you can just plug this USB cable (step 3) into that Linux system, and
it will automatically create a "/dev/tty*" file for this connection when you
plug it in and the Zed board is powered up.  You need to determine this pathname
- and watch it come and go when you disconnect and reconnect the USB cable (or
when the Zed board is powered down and up).

Without any other configuration of the Linux development host, you typically
have to add read/write permission to this "/dev/tty*" file manually EACH TIME
THE CABLE IS CONNECTED AND/OR THE ZED BOARD IS POWERED ON, using:

% sudo chmod a+rw /dev/ttyACM0

(assuming the /dev/tty* file created for that cable is /dev/ttyACM0, which is
the default for the first such hotplugged USB/serial cable on Centos6).  Again,
this must be done each time the board is power cycled or disconnected.

(This can be automated with udev configuration if you want to go there)
(TBD: explain how to automate this).

Step 7: Run a serial console terminal emulator program on the development
system that is attached to the USB cable from the UART connector.

There are many alternative terminal emulation applications to provide for
this USB remote serial console for the Zed board (or any similar board).
One that is available in the standard Centos 6 repository is "screen",
obtainable by simply using:

% sudo yum install screen

Then in any terminal window, you can do:

% screen /dev/ttyACM0 115200

To exit this program, you use the sequence: Control-a followed by backslash.

For Emacs users, you can use the serial terminal emulator built in to Emacs, by
simply doing: M-x serial-term in a window, and providing the /dev/ttyACM0 name
and 115200 baud rate when prompted.  There are two modes in this window, "char"
and "line".  The default is "char" mode, where every character typed is
immediately sent without any interpretation at all.  This means no emacs
commands work in that emacs window and you have to use the mouse to switch to
another window.  The "line" mode is more line buffered, like "shell" mode, and
all line editing and other emacs commands work fine.  BUT the display can get
confused in line mode so you have sometimes switch back and forth.  control-c
control-j switches to line mode, control-c control-k switches to char mode.
Control-c control-c sends a control C in char mode.

(TBD: fix the glitch in emacs serial-term line mode so this works better).
(TBD: fix so control-c twice in line mode does the right thing)

Step 8: hit return a few times in the serial console window to see the "zynq
login:" prompt, or, if the system was previously logged in and running, you
might see the "root@zynq:~#" prompt.  You must login as "root" with the password
"root".

Sometimes if the screen or terminal emulator is confused, or if, after hitting
"return", the prompt stays on the same line, try typing the command "clear", to
clear the state of the terminal emulator.

********* The above confirms serial console access and a booted system**********

================================================================================

****** Get the network working in order to talk to the development system*******

Step 9: Connect the ethernet connector on the Zed board to a LAN with DHCP.

The green light that is part of the network connector socket should come on to
indicate that you have a network connection.

Step 10: Reboot the Zed board to have it come up properly on the network.

You can reboot either by typing the "reboot" command, pressing the "PS-RST"
button, or turning the power switch off and on.  Power cycling might cause you
to need to do another "sudo chmod a+rw /dev/ttyACM0".  After reboot, and
re-login, you can use the ifconfig command to confirm that the "eth0" interface
has an internet address, courtesy of DHCP.  E.g. this shows we have the internet
address 10.0.1.108.

  root@zynq:~# ifconfig
  eth0      Link encap:Ethernet  HWaddr 00:0A:35:00:01:22  
            inet addr:10.0.1.108  Bcast:0.0.0.0  Mask:255.255.255.0
            inet6 addr: fe80::20a:35ff:fe00:122/64 Scope:Link
            UP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1
            RX packets:42 errors:0 dropped:1 overruns:0 frame:0
            TX packets:14 errors:0 dropped:0 overruns:0 carrier:0
            collisions:0 txqueuelen:1000 
            RX bytes:6793 (6.6 KiB)  TX bytes:1737 (1.6 KiB)
            Interrupt:54 Base address:0xb000 

Note your "mysetup.sh" script you copied to the SD card should have the
development system's IP address, along with some NTP server name.

Step 11: Mount the SD card as a file system

After logging in as root, the first command should be:

   root@zynq:~# mount /dev/mmcblk0p1 /mnt/card

Which allows you to use the contents of the SD card for something other than booting.

Step 12: Source the startup script on the SD card:

   root@zynq:~# source /mnt/card/mysetup.sh

   root@zynq:~# ocpirun

If this works ok, then it proves you can run OpenCPI utilities (and applications).

*** The steps above enable OpenCPI on zed board, with the development system ***

================================================================================


** The steps below confirm OpenCPI operation, including running an FPGA-based app****

Step 13: Run a software-component-based application.

Note that the setup.sh script above already sets the path to find OpenCPI
executables and software components.   Below "xxxxxx" is the path to
get to the OpenCPI development tree.

zynq> cd /mnt/net/xxxxxx/opencpi/tools/cdk/examples/xml
zynq> ocpirun -v -d -t 5 tb_bias

This should run the tb_bias application (using pattern->bias->capture) components.

Step 17: Run a FPGA-based application

There is no bitstream loaded on power up.  You can simply, after power up,
manually load a bitstream.  Note that on other OpenCPI
platforms you usually are *required* to put an OpenCPI bitstream into the boot flash.
For Zed/Zynq, this is not required.  You can manually load a bitstream
directory on a system using the "ocpihdl load" command:

zynq> ocpihdl load /mnt/net/xxxxxx/opencpi/hdl/assemblies/tb_bias/target-tb_bias_zed_base/tb_bias-tb_bias_zed_base.bit.gz

Next, (from the same directory) we can add to the OCPI_LIBRARY_PATH to find
the bitstream we need.

zynq> export OCPI_LIBRARY_PATH=/mnt/nfs/xxxxxx/opencpi/hdl/assemblies/tb_bias_vhdl:$OCPI_LIBRARY_PATH
zynq> ocpirun -v -d -t 5 tb_bias

This should run the same application, but with the components found in a bitstream.
The bitstream will be autoloaded onto the FPGA (a.k.a. PL) of the Zynq.

Note that our preloaded bitstream was from the "tb_bias" directory, whereas the
directory we put in the OCPI_LIBRARY_PATH was the "tb_bias_vhdl" directory, which
caused the latter bitstream to be autoloaded during the ocpirun.

TODO:  A list of things that will make this all a bit more convenient:

1. Allow there to be no bitstream loaded when we try to run an application
   -- avoiding the need for the extra "ocpihdl load"
2. Cause the /mnt/card mounting to happen automatically at boot time.
   -- avoiding the need to mount it to access the startup script
3. Perhaps cause the "setup" script to be run automatically at boot time.
   -- avoiding the command to run the startup script
4. On the development system, provide udv rules to avoid the "sudo chmod" command
   -- avoid needing to do sudo chmod command each time the board power cycles

By the way, if you do want to rebuild or otherwise play with the u-boot boot
loader and the linux kernel, the sources that Xilinx used to build the release
archive used above are found at: https://github.com/Xilinx, using the linux-xlnx
git repository and the uboot git repository.  Both are labelled for each
release.  E.g. the 14.6 release is labeled "xilinx-v14.6".

Note that the original contents of the SD card can be found on the Digilent web
site under the "out of box" project at http://www.zedboard.org/node/241.  But
you don't need this if you are just following these directions.
