#include "matrix.h"


extern "C++" {
#include <iostream>
#include <math.h>
};

#include <cilk.h>
#include <cilkview.h>


using namespace OCPI::RCC; // for easy access to RCC data types and constants

#define DEFAULT_MATRIX_SIZE 1000
// cilk_for granularity.
#define CILK_FOR_GRAINSIZE 128


// Transpose a double precsion square n x n matrix, A, in place
void matrix_transpose(float* A, int l2dim )
{
  int n = (int)sqrt(l2dim);
    //  #pragma cilk_grainsize allows expressions, such as n/4
    //#pragma cilk_grainsize=CILK_FOR_GRAINSIZE
    cilk_for(int i = 1; i < n; ++i) {

	printf(" In loop, id = %d\n", cilk::current_worker_id() );

        // This is the only Cilk++ keyword used in this program
        for (int j = 0; j < i; ++j) {
            // Swap A[i][j] and A[j][i]. The matrix is treated as one-dimensional.
	  float temp = A[j* n + i];
	  A[j * n + i] = A[i * n + j];
	  A[i * n + j] = temp;
        }
    }
    return;
}


class Cilkmatrix_ccWorker : public Cilkmatrix_ccWorkerBase {

  struct CilkArgs {
    uint32_t timeout;
    Cilkmatrix_ccWorker * worker;
    RCCResult * result;
  };

  static int __cilk cilkEntrypointWrapper (void *pargs )
  {
    printf("In wrapper \n");
    // Unbundle the parameters and do the work
    CilkArgs * args = (CilkArgs*)pargs;
    printf("In cilk context\n");
    *args->result = args->worker->run_cilk( args->timeout );
    return 0;
  }

  RCCResult run(bool timeout ) {
      cilk::context cilkCtx;
      printf("Running Cilk worker \n");
      RCCResult rc;
      
         CilkArgs args = { timeout, this, &rc  };
//      cilkCtx.set_worker_count( 2 );  // Number of cores to use      
      printf("calling wrapper 1\n");

      cilkCtx.run( (cilk::pcilkfn)cilkEntrypointWrapper, (void *)&args);      
      return rc;
    }
  

  RCCResult __cilk run_cilk(bool /*timedout*/) {

    std::cout << "In CILK RUN !!" << std::endl;

    float *inData  = (float*)in.data().data;   // data arg of data message at "in" port

    // not setting the output data for this demo yet
    //    uint32_t *outData = out.data().data;  // same at "out" port
    out.checkLength( in.length());               // make sure input will fit in output buffer

    std::cout << "About to run transpose" << std::endl;

    matrix_transpose(inData, in.length()/sizeof(float));

    out.setInfo( in.opCode(), in.length());      // Set the metadata for the output message

    return in.length() ? OCPI::RCC::RCC_ADVANCE : OCPI::RCC::RCC_ADVANCE_DONE;
  }

};

CILKMATRIX_CC_START_INFO
// Insert any static info assignments here (memSize, memSizes, portInfo)
// e.g.: info.memSize = sizeof(MyMemoryStruct);
CILKMATRIX_CC_END_INFO


